using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using UnityEngine.InputSystem;

public class LevelGenerator : MonoBehaviour
{
    public static LevelGenerator instance;

    public GameObject floorParent; // holds all active floors

    [HideInInspector] public FloorEventMap floorEventMap;
    [HideInInspector] public FloorEventMap highFloorEventMap;
    [HideInInspector] public FloorEventMap lowFloorEventMap;

    public GameObject blockPrefab;

    OWPlayerController owPlayer;

    public ColorToTile[] colorMappings;

    public GameObject[,] eventTilemap; // these arrays will be reserved for mesh objects generated by floorEventMaps
    public GameObject[,] higherEventTilemap;
    public GameObject[,] lowerEventTilemap;

    public GameObject[,] tilemap;
    public EventBranch[,] floorEvents;
    public bool[,] walkable;

    private GameObject currentFloor;
    private GameObject lowerFloor;
    private GameObject higherFloor;
    private GameObject tempFloor;

    [SerializeField] private MaterialFadeController wallMatFade;
    [SerializeField] private MaterialFadeController floorMatFade;

    [SerializeField] float transitionCamZoom = 0.35f;
    Vector3 transitionCamPos = Vector3.zero;

    [SerializeField] float fadeSpeedMod;

    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        floorParent = new GameObject("FloorParent");
        floorParent.transform.SetParent(transform);

        wallMatFade = new MaterialFadeController();
        floorMatFade = new MaterialFadeController();
        SendMaterialsToFadeController();

        //GetNewLevelMaps();
        GenerateNewFloors();
        SpawnPlayer(Mathf.RoundToInt(GameManager.instance.spawnPos.x), Mathf.RoundToInt(GameManager.instance.spawnPos.y));
        GameObject.Find("Minimap").GetComponent<Minimap>().CreateMap(walkable);

        StartCoroutine(SetInitialFloorNum());
    }

    private IEnumerator SetInitialFloorNum()
    {
        //Debug.Log("Setting initial floor number ...");
        while(GameManager.instance == null || UIManager.instance == null)
        {
            yield return new WaitForEndOfFrame();
        }

        StartCoroutine(UpdateFloorNum());
    }

    private void Update()
    {
        wallMatFade.SetMaterialAlpha();
        floorMatFade.SetMaterialAlpha();

        var keyboard = Keyboard.current;

        if (keyboard.rKey.wasPressedThisFrame)
        {
            Debug.Log("Resetting floors.");
            ResetFloors();
        }
    }

    private void SendMaterialsToFadeController()
    {
        wallMatFade.mat = blockPrefab.GetComponent<Renderer>().sharedMaterial;
        floorMatFade.mat = blockPrefab.transform.GetChild(0).GetComponent<Renderer>().sharedMaterial;
    }

    #region Stairs
    public void BeginStairsTransition(bool goingUp)
    {
        //Debug.Log("Using Stairs to get to Floor " + GameManager.instance.floor);
        int floorChoice = 1;
        if (!goingUp)
        {
            floorChoice = -1;
        }

        /// run coroutine to climb stairs
        StartCoroutine(StairClimbTransition(floorChoice));
    }
    private IEnumerator StairClimbTransition(int goingUp)
    {
        owPlayer.TargetGridPos = owPlayer.PrevTargetGridPos;

        owPlayer.eventInteraction = false;
        owPlayer.ignoreCollision = true;
        owPlayer.GetComponent<OWPlayerInput>().acceptInputs = false;
        owPlayer.GetComponent<OWPlayerLook>().overwriteCamPos = true;
        Vector3 newFloorParentPos = new Vector3(Mathf.RoundToInt(floorParent.transform.position.x),
            Mathf.RoundToInt(floorParent.transform.position.y + (-goingUp * (Vector3.up.y * 2))),
            Mathf.RoundToInt(floorParent.transform.position.z));

        Camera playerCamera = owPlayer.GetComponentInChildren<Camera>();

        Vector3 playerTargetPos = new Vector3(Mathf.RoundToInt(owPlayer.transform.localPosition.x + (owPlayer.transform.forward.x * 3)), 0f,
            Mathf.RoundToInt(owPlayer.transform.localPosition.z + (owPlayer.transform.forward.z * 3)));
        while (owPlayer.transform.localPosition != playerTargetPos || floorParent.transform.position != newFloorParentPos)
        {
            owPlayer.TargetGridPos = playerTargetPos;
            floorParent.transform.position = Vector3.MoveTowards(floorParent.transform.position, newFloorParentPos,
                Time.deltaTime * (owPlayer.transitionSpeed * 0.25f));

            if(Vector3.Distance(floorParent.transform.position, newFloorParentPos) > 0.5f)
            {
                playerCamera.transform.localPosition = Vector3.MoveTowards(playerCamera.transform.localPosition, transitionCamPos,
                    1.5f * transitionCamZoom * Time.deltaTime);
            }
            else
            {
                playerCamera.transform.localPosition = Vector3.MoveTowards(playerCamera.transform.localPosition, new Vector3(0, 0, -0.7f),
                    1.5f * transitionCamZoom * Time.deltaTime);
            }

            yield return new WaitForEndOfFrame();
        }

        /// flush current floorEvents on currentFloor

        Destroy(tempFloor);
        tempFloor = null;

        owPlayer.ignoreCollision = false;
        owPlayer.eventInteraction = true;
        owPlayer.GetComponent<OWPlayerInput>().acceptInputs = true;
        owPlayer.GetComponent<OWPlayerLook>().overwriteCamPos = false;
        StartCoroutine(UpdateFloorNum());

        ResetFloors();

        /// Advance Event Queue
        GameManager.instance.advanceEvent = true;
    }
    #endregion
    #region Ladder
    public void BeginLadderTransition(bool goingUp, int newArea, int newFloor)
    {
        //Debug.Log("Using Ladder to get to Area " + GameManager.instance.area + ", Floor " + GameManager.instance.floor);

        StartCoroutine(LadderTransition());
    }
    public IEnumerator LadderTransition()
    {
        // IMPORTANT NOTES BELOW

        // fade wall and floor materials
        // unload floors
        // regenerate aimed floor, and low and high floors, like when the game starts

        owPlayer.GetComponent<OWPlayerInput>().acceptInputs = false;
        owPlayer.GetComponent<OWPlayerLook>().overwriteCamPos = true;
        owPlayer.eventInteraction = false;
        owPlayer.ignoreCollision = true;

        while (owPlayer.transform.position != owPlayer.TargetGridPos)
        {
            yield return new WaitForEndOfFrame();
        }

        while (floorMatFade.colorAlpha > 0f)
        {
            floorMatFade.colorAlpha -= Time.deltaTime * fadeSpeedMod;
            wallMatFade.colorAlpha = floorMatFade.colorAlpha;
            yield return new WaitForEndOfFrame();
        }

        yield return new WaitForSeconds(0.5f);

        ResetFloors();

        ///// run coroutine to climb stairs
        //StartCoroutine(StairClimbTransition(floorChoice));

        //GenerateNewFloors();

        // unfade wall and floor materials
        StartCoroutine(UpdateFloorNum());

        while (floorMatFade.colorAlpha < 1f)
        {
            floorMatFade.colorAlpha += Time.deltaTime * fadeSpeedMod;
            wallMatFade.colorAlpha = floorMatFade.colorAlpha;
            yield return new WaitForEndOfFrame();
        }

        owPlayer.ignoreCollision = false;
        owPlayer.eventInteraction = true;
        owPlayer.MoveBackward();
        owPlayer.GetComponent<OWPlayerInput>().acceptInputs = true;
        owPlayer.GetComponent<OWPlayerLook>().overwriteCamPos = false;

        /// Advance Event Queue
        GameManager.instance.advanceEvent = true;
    }
    #endregion

    private void GenerateNewFloors()
    {
        GetNewLevelMaps();

        currentFloor = new GameObject("CurrentFloor");
        currentFloor.transform.SetParent(floorParent.transform);
        GenerateFloor(currentFloor, floorEventMap, 0f);
        currentFloor.transform.localPosition = Vector3.zero;
        currentFloor.transform.localRotation = Quaternion.identity;

        higherFloor = new GameObject("HigherFloor");
        higherFloor.transform.SetParent(floorParent.transform);
        GenerateFloor(higherFloor, highFloorEventMap, 1f);
        higherFloor.transform.localPosition = new Vector3(0f, 2f, 0f);
        higherFloor.transform.localRotation = Quaternion.identity;

        lowerFloor = new GameObject("LowerFloor");
        lowerFloor.transform.SetParent(floorParent.transform);
        GenerateFloor(lowerFloor, lowFloorEventMap, -1f);
        lowerFloor.transform.localPosition = new Vector3(0f, -2f, 0f);
        lowerFloor.transform.localRotation = Quaternion.identity;
    }

    public void ResetCurrentFloor()
    {
        ResetFloorParentPosition();
        Destroy(currentFloor);
        currentFloor = new GameObject("CurrentFloor");
        currentFloor.transform.SetParent(floorParent.transform);
        GenerateFloor(currentFloor, floorEventMap, 0f);
        currentFloor.transform.localPosition = Vector3.zero;
        currentFloor.transform.localRotation = Quaternion.identity;
        GameObject.Find("Minimap").GetComponent<Minimap>().CreateMap(walkable);

        Destroy(tempFloor);
        tempFloor = null;
    }
    public void ResetFloors()
    {
        GameObject tempFloor1 = currentFloor;
        GameObject tempFloor2 = higherFloor;
        GameObject tempFloor3 = lowerFloor;
        GenerateNewFloors();
        floorParent.transform.position = Vector3.zero;
        Destroy(tempFloor1);
        Destroy(tempFloor2);
        Destroy(tempFloor3);
    }

    private IEnumerator UpdateFloorNum()
    {
        UIManager.instance.UpdateFloorNumText();
        yield return new WaitForEndOfFrame();
    }

    private void ResetFloorParentPosition()
    {
        currentFloor.transform.parent = null;
        higherFloor.transform.parent = null;
        lowerFloor.transform.parent = null;
        floorParent.transform.localPosition = Vector3.zero;
        currentFloor.transform.SetParent(floorParent.transform);
        higherFloor.transform.SetParent(floorParent.transform);
        lowerFloor.transform.SetParent(floorParent.transform);
    }

    private void GenerateFloor(GameObject parentTransformGO, FloorEventMap newMap, float highOrLow)
    {
        if(highOrLow == 0f)
        {
            walkable = new bool[newMap.floorMap.width, newMap.floorMap.height];
            tilemap = new GameObject[newMap.floorMap.width, newMap.floorMap.height];
        }
        for (int x = 0; x < newMap.floorMap.width; x++)
        {
            for (int y = 0; y < newMap.floorMap.height; y++)
            {
                GenerateTile(x, y, newMap.floorMap, parentTransformGO);
            }
        }
        GenerateFloorEvents(parentTransformGO, newMap, highOrLow);
    }
    private void GenerateFloorEvents(GameObject parentTransformGO, FloorEventMap newMap, float highOrLow)
    {
        if (highOrLow == 0f)
        {
            floorEvents = new EventBranch[newMap.floorMap.width, newMap.floorMap.height];
        }
        // Going to need to have special object loading protocols for specific event types
        for (int x = 0; x < newMap.floorMap.width; x++)
        {
            for (int y = 0; y < newMap.floorMap.height; y++)
            {
                if (newMap.eventBranches == null)
                {
                    return;
                }
                if (newMap.eventBranches.Length < 1)
                {
                    return;
                }
                EventBranch[] currentBranches = newMap.eventBranches;

                /// IMPORTANT: The code below is bugged to set every event to the same thing! Fix this! Add a check that that mapPos matches!
                for (int branch = 0; branch < currentBranches.Length; branch++)
                {
                    currentBranches[branch].InitializeEvents();
                    if (currentBranches[branch].mapPos.x == x && currentBranches[branch].mapPos.y == y && highOrLow == 0)
                    {
                        floorEvents[x, y] = currentBranches[branch];
                    }
                }
            }
        }
        //Debug.Log((floorEvents[1, 8].eventPages[0].eventSequence.events[0].dialogParams.dialogEventData.dialogSets[0].dialogs[0].sentences[0]));
        //if(floorEvents[9, 4] != null)
        //{
        //    Debug.Log((floorEvents[9, 4].eventPages[0].eventSequence.events[0].typeOfEvent));
        //}
    }

    private void GenerateTile(int x, int y, Texture2D newMap, GameObject parentTransformGO)
    {
        Color pixelColor = newMap.GetPixel(x, y);

        Vector3 position = new Vector3(x, 0, y);

        foreach(ColorToTile colorMapping in colorMappings)
        {
            if (colorMapping.color.Equals(pixelColor))
            {
                GameObject blockGO = Instantiate(blockPrefab, position, Quaternion.identity, parentTransformGO.transform);
                colorMapping.PrepareBlock(blockGO.transform);
                if (newMap == floorEventMap.floorMap)
                {
                    walkable[x, y] = GetTileWalkable(colorMapping);
                    tilemap[x, y] = blockGO;
                }
            }
        }
    }

    private void SpawnPlayer(int x, int y)
    {
        owPlayer = GameObject.Find("OWPlayer").GetComponent<OWPlayerController>();
        owPlayer.TargetGridPos = Vector3Int.RoundToInt(new Vector3(x, 0, y));
        owPlayer.PrevTargetGridPos = owPlayer.TargetGridPos;
        owPlayer.transform.position = owPlayer.TargetGridPos;
    }

    private bool GetTileWalkable(ColorToTile refTile)
    {
        return (refTile.blockType == BlockType.Floor);
    }

    public void GetNewLevelMaps() // IMPORTANT: Rewrite this entire function
    {
        floorEventMap = Resources.Load<FloorEventMap>("ScriptableObjects/EventMap/eventmap_" + GameManager.instance.area + "_" + GameManager.instance.floor);
        if (floorEventMap == null) floorEventMap = ScriptableObject.CreateInstance<FloorEventMap>();
        highFloorEventMap = Resources.Load<FloorEventMap>("ScriptableObjects/EventMap/eventmap_" + GameManager.instance.area + "_" + (GameManager.instance.floor + 1));
        if (highFloorEventMap == null) highFloorEventMap = ScriptableObject.CreateInstance<FloorEventMap>();
        lowFloorEventMap = Resources.Load<FloorEventMap>("ScriptableObjects/EventMap/eventmap_" + GameManager.instance.area + "_" + (GameManager.instance.floor - 1));
        if (lowFloorEventMap == null) lowFloorEventMap = ScriptableObject.CreateInstance<FloorEventMap>();
    }

    //private GameObject GenerateObject(int x, int y, int objID, GameObject parentTransformGO, int rotation)
    //{
    //    Vector3 position = new Vector3(x, 0, y);

    //    GameObject objGO = Instantiate(assets.prefabs[objID], position, Quaternion.Euler(0, (int)(rotation * 90), 0), parentTransformGO.transform);
    //    objmap[x, y] = objGO;

    //    return objGO;
    //}

    public void SetTileWalkable(int x, int y, bool val)
    {
        walkable[x, y] = val;
    }
}
